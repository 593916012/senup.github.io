<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/home.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/home.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="xYfyORg7NRaZ710bOerpWDuZ6ftibqls5bOt3eiFSoM">
  <meta name="baidu-site-verification" content="FhQkF9o54P">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.senup.cn","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":30,"onmobile":true},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":true,"lazyload":false,"pangu":false,"comments":{"style":"buttons","active":"valine","storage":true,"lazyload":false,"nav":null,"activeClass":"valine"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":5,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="面试笔记">
<meta name="keywords" content="技术">
<meta property="og:type" content="article">
<meta property="og:title" content="mysql">
<meta property="og:url" content="https://www.senup.cn/p/3361.html">
<meta property="og:site_name" content="Senup">
<meta property="og:description" content="面试笔记">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://img-blog.csdn.net/20170705172036010?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemdyZ2Zy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
<meta property="og:image" content="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/jojo/system-design/mysql/ibd/innodb-table-structure.png">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/5148507-1684dba15ec6fb78.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp">
<meta property="og:updated_time" content="2020-10-30T02:30:23.135Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="mysql">
<meta name="twitter:description" content="面试笔记">
<meta name="twitter:image" content="https://img-blog.csdn.net/20170705172036010?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemdyZ2Zy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">

<link rel="canonical" href="https://www.senup.cn/p/3361.html">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>mysql | Senup</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Senup</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">走在风中 今天阳光 突然好温柔</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-life">

    <a href="/categories/生活" rel="section"><i class="fa fa-heartbeat fa-fw"></i>生活</a>

  </li>
        <li class="menu-item menu-item-technology">

    <a href="/categories/技术" rel="section"><i class="fa fa-calendar fa-fw"></i>技术</a>

  </li>
        <li class="menu-item menu-item-guitar">

    <a href="/categories/吉他" rel="section"><i class="fa fa-tags fa-fw"></i>吉他</a>

  </li>
        <li class="menu-item menu-item-books">

    <a href="/books/" rel="section"><i class="fa fa-book fa-fw"></i>读书</a>

  </li>
        <li class="menu-item menu-item-movies">

    <a href="/movies/" rel="section"><i class="fa fa-film fa-fw"></i>电影</a>

  </li>
        <li class="menu-item menu-item-games">

    <a href="/games/" rel="section"><i class="fa fa-gamepad fa-fw"></i>游戏</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-notes">

    <a href="/notes/" rel="section"><i class="fa fa-comment fa-fw"></i>留言板</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/senup" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.senup.cn/p/3361.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1.jpeg">
      <meta itemprop="name" content="高等游民">
      <meta itemprop="description" content="卷发星人/程序猿/指弹菜鸟/社恐肥宅">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Senup">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          mysql
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-09 09:33:06" itemprop="dateCreated datePublished" datetime="2020-09-09T09:33:06+08:00">2020-09-09</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/p/3361.html#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/p/3361.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>13k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>12 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>面试笔记</p>
<a id="more"></a>





<h2 id="什么是数据库事务、数据库事务的四个特性是什么。"><a href="#什么是数据库事务、数据库事务的四个特性是什么。" class="headerlink" title="什么是数据库事务、数据库事务的四个特性是什么。"></a>什么是数据库事务、数据库事务的四个特性是什么。</h2><p>事务就是一组SQL语句，要么全部执行成功，要么全部执行失败。</p>
<p>原子性 一致性 隔离性 持久性</p>
<hr>
<h2 id="请分别举例说明幻读和不可重复读、并描述一下它们之间的区别。"><a href="#请分别举例说明幻读和不可重复读、并描述一下它们之间的区别。" class="headerlink" title="请分别举例说明幻读和不可重复读、并描述一下它们之间的区别。"></a>请分别举例说明幻读和不可重复读、并描述一下它们之间的区别。</h2><p>幻读是指由于并发事务存在导致说前后读取的记录不一致，后来多出现几条记录，如同出现了幻觉。</p>
<p>不可重复读是指由于并发事务存在导致前后读取的记录不一致，因此称为不可重复读。</p>
<hr>
<h2 id="MySQL-的默认隔离级别是什么。"><a href="#MySQL-的默认隔离级别是什么。" class="headerlink" title="MySQL 的默认隔离级别是什么。"></a>MySQL 的默认隔离级别是什么。</h2><p>总共4个级别，默认处在第三级，也就是可重复读的级别，由于MySQL实现了next-key lock锁，它是由记录锁和间隙锁实现的，所以在可重复读的级别也避免了幻读的问题。</p>
<hr>
<h2 id="为什么要使用索引。"><a href="#为什么要使用索引。" class="headerlink" title="为什么要使用索引。"></a>为什么要使用索引。</h2><p>能够加快查询速度</p>
<hr>
<h2 id="索引这么多优点，为什么不对表中每个字段都创建索引呢。"><a href="#索引这么多优点，为什么不对表中每个字段都创建索引呢。" class="headerlink" title="索引这么多优点，为什么不对表中每个字段都创建索引呢。"></a>索引这么多优点，为什么不对表中每个字段都创建索引呢。</h2><p>因为维护索引的过程会导致增删改的维护成本加大。</p>
<p>索引占空间</p>
<hr>
<h2 id="索引是如何提升查询速度的。"><a href="#索引是如何提升查询速度的。" class="headerlink" title="索引是如何提升查询速度的。"></a>索引是如何提升查询速度的。</h2><p>没有索引之前，MySQL中记录都是存储在页里面的，页是一种双向链表的结构，页中的记录是一个单链表的结构，因此查询效率低下。有了索引之后，能够将链表结构从无序组织到有序，利用了类似树的结构，能够在稳定的时间内查找到想要的数据。</p>
<h2 id="请说出你知道的索引失效的几种情况。"><a href="#请说出你知道的索引失效的几种情况。" class="headerlink" title="请说出你知道的索引失效的几种情况。"></a>请说出你知道的索引失效的几种情况。</h2><p>1.如果条件中有or，即使其中有条件带索引也不会使用(这也是为什么尽量少用or的原因)，注意：要想使用or，又想让索引生效，只能将or条件中的每个列都加上索引<br>2，对于多列索引，不是使用的第一部分，则不会使用索引(详情可见上篇文章)<br>3，like查询是以%开头<br>4，如果列类型是字符串，那一定要在条件中将数据使用引号引用起来,否则不使用索引<br>5，在索引列上进行计算或使用函数索引将失效<br>6，where子句中使用参数，会导致全表扫描</p>
<hr>
<h2 id="什么是聚簇索引与非聚簇索引"><a href="#什么是聚簇索引与非聚簇索引" class="headerlink" title="什么是聚簇索引与非聚簇索引"></a>什么是聚簇索引与非聚簇索引</h2><p>聚集索引即索引结构和数据一起存放的索引。主键索引属于聚集索引。</p>
<p>非聚集索引即索引结构和数据分开存放的索引。</p>
<p>二级索引属于非聚集索引。</p>
<hr>
<h2 id="MySQL-索引主要使用的数据结构有哪些。"><a href="#MySQL-索引主要使用的数据结构有哪些。" class="headerlink" title="MySQL 索引主要使用的数据结构有哪些。"></a>MySQL 索引主要使用的数据结构有哪些。</h2><p>目前大部分数据库系统及文件系统都采用B-Tree或其变种B+Tree作为索引结构</p>
<h2 id="谈谈-MyISAM-和-InnoDb-实现-BTree-索引方式的区别。"><a href="#谈谈-MyISAM-和-InnoDb-实现-BTree-索引方式的区别。" class="headerlink" title="谈谈 MyISAM 和 InnoDb 实现 BTree 索引方式的区别。"></a>谈谈 MyISAM 和 InnoDb 实现 BTree 索引方式的区别。</h2><p>MyISAM中索引检索的算法为首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录。<br>MyISAM的索引方式也叫做“非聚集”的。</p>
<p>第一个重大区别是InnoDB的数据文件本身就是索引文件。MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。而在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。</p>
<p>InnoDB的辅助索引data域存储相应记录主键的值而不是地址。</p>
<h2 id="什么是覆盖索引、请举例说明。"><a href="#什么是覆盖索引、请举例说明。" class="headerlink" title="什么是覆盖索引、请举例说明。"></a>什么是覆盖索引、请举例说明。</h2><p>索引包含所有需要查询的字段的值。</p>
<p>具有以下优点：</p>
<ul>
<li>索引通常远小于数据行的大小，只读取索引能大大减少数据访问量。</li>
<li>一些存储引擎（例如 MyISAM）在内存中只缓存索引，而数据依赖于操作系统来缓存。因此，只访问索引可以不使用系统调用（通常比较费时）。</li>
<li>对于 InnoDB 引擎，若辅助索引能够覆盖查询，则无需访问主索引。</li>
</ul>
<hr>
<h2 id="谈谈你对最左前缀原则的理解。"><a href="#谈谈你对最左前缀原则的理解。" class="headerlink" title="谈谈你对最左前缀原则的理解。"></a>谈谈你对最左前缀原则的理解。</h2><p>最左前缀原则指的是，如果查询的时候查询条件精确匹配索引的左边连续一列或几列，则此列就可以被用到。</p>
<hr>
<h2 id="MySQL-中-InnoDb-和-MyISAM-有什么区别。"><a href="#MySQL-中-InnoDb-和-MyISAM-有什么区别。" class="headerlink" title="MySQL 中 InnoDb 和 MyISAM 有什么区别。"></a>MySQL 中 InnoDb 和 MyISAM 有什么区别。</h2><p>外键 事务 表级锁行级锁  聚簇索引非聚簇索引 全文索引 </p>
<hr>
<h2 id="谈谈如何对SQL进行优化。"><a href="#谈谈如何对SQL进行优化。" class="headerlink" title="谈谈如何对SQL进行优化。"></a>谈谈如何对SQL进行优化。</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">1.对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。	</span><br><span class="line">	</span><br><span class="line">2.应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：	</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span> <span class="keyword">is</span> <span class="literal">null</span>	</span><br><span class="line">可以在<span class="keyword">num</span>上设置默认值<span class="number">0</span>，确保表中<span class="keyword">num</span>列没有<span class="literal">null</span>值，然后这样查询：	</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span>=<span class="number">0</span>	</span><br><span class="line">	</span><br><span class="line"><span class="number">3.</span>应尽量避免在 <span class="keyword">where</span> 子句中使用!=或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描。	</span><br><span class="line">	</span><br><span class="line"><span class="number">4.</span>应尽量避免在 <span class="keyword">where</span> 子句中使用 <span class="keyword">or</span> 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，如：	</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span>=<span class="number">10</span> <span class="keyword">or</span> <span class="keyword">num</span>=<span class="number">20</span>	</span><br><span class="line">可以这样查询：	</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span>=<span class="number">10</span>	</span><br><span class="line"><span class="keyword">union</span> <span class="keyword">all</span>	</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span>=<span class="number">20</span>	</span><br><span class="line">	</span><br><span class="line"><span class="number">5.</span><span class="keyword">in</span> 和 <span class="keyword">not</span> <span class="keyword">in</span> 也要慎用，否则会导致全表扫描，如：	</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span> <span class="keyword">in</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)	</span><br><span class="line">对于连续的数值，能用 <span class="keyword">between</span> 就不要用 <span class="keyword">in</span> 了：	</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span> <span class="keyword">between</span> <span class="number">1</span> <span class="keyword">and</span> <span class="number">3</span>	</span><br><span class="line">	</span><br><span class="line"><span class="number">6.</span>避免在<span class="keyword">like</span>操作中以通配符%开头：</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">like</span> <span class="string">'%abc%'</span>	</span><br><span class="line">	</span><br><span class="line"><span class="number">7.</span>应尽量避免在 <span class="keyword">where</span> 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。如：	</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span>/<span class="number">2</span>=<span class="number">100</span>	</span><br><span class="line">应改为:	</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span>=<span class="number">100</span>*<span class="number">2</span>	</span><br><span class="line">	</span><br><span class="line"><span class="number">8.</span>应尽量避免在<span class="keyword">where</span>子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。如：	</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">substring</span>(<span class="keyword">name</span>,<span class="number">1</span>,<span class="number">3</span>)=<span class="string">'abc'</span>————<span class="keyword">name</span>以abc开头的<span class="keyword">id</span></span><br><span class="line">应改为:	</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">like</span> <span class="string">'abc%'</span>	</span><br><span class="line">	</span><br><span class="line"><span class="number">9.</span>不要在 <span class="keyword">where</span> 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。	</span><br><span class="line">	</span><br><span class="line"><span class="number">10.</span>在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，	</span><br><span class="line">否则该索引将不会被使用，并且应尽可能的让字段顺序与索引顺序相一致。	</span><br><span class="line">	</span><br><span class="line"><span class="number">11.</span>不要写一些没有意义的查询，如需要生成一个空表结构：	</span><br><span class="line"><span class="keyword">select</span> col1,col2 <span class="keyword">into</span> <span class="comment">#t from t where 1=0	</span></span><br><span class="line">这类代码不会返回任何结果集，但是会消耗系统资源的，应改成这样：	</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="comment">#t(...)	</span></span><br><span class="line">	</span><br><span class="line"><span class="number">12.</span>很多时候用 <span class="keyword">exists</span> 代替 <span class="keyword">in</span> 是一个好的选择：	</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">num</span> <span class="keyword">from</span> a <span class="keyword">where</span> <span class="keyword">num</span> <span class="keyword">in</span>(<span class="keyword">select</span> <span class="keyword">num</span> <span class="keyword">from</span> b)	</span><br><span class="line">用下面的语句替换：	</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">num</span> <span class="keyword">from</span> a <span class="keyword">where</span> <span class="keyword">exists</span>(<span class="keyword">select</span> <span class="number">1</span> <span class="keyword">from</span> b <span class="keyword">where</span> <span class="keyword">num</span>=a.num)	</span><br><span class="line">	</span><br><span class="line"><span class="number">13.</span>并不是所有索引对查询都有效，<span class="keyword">SQL</span>是根据表中数据来进行查询优化的，当索引列有大量数据重复时，<span class="keyword">SQL</span>查询可能不会去利用索引，	</span><br><span class="line">如一表中有字段sex，male、female几乎各一半，那么即使在sex上建了索引也对查询效率起不了作用。	</span><br><span class="line">	</span><br><span class="line"><span class="number">14.</span>索引并不是越多越好，索引固然可以提高相应的 <span class="keyword">select</span> 的效率，但同时也降低了 <span class="keyword">insert</span> 及 <span class="keyword">update</span> 的效率，	</span><br><span class="line">因为 <span class="keyword">insert</span> 或 <span class="keyword">update</span> 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。	</span><br><span class="line">一个表的索引数最好不要超过<span class="number">6</span>个，若太多则应考虑一些不常使用到的列上建的索引是否有必要。	</span><br><span class="line">	</span><br><span class="line"><span class="number">15.</span>尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。	</span><br><span class="line">这是因为引擎在处理查询和连接时会逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。	</span><br><span class="line">	</span><br><span class="line"><span class="number">16.</span>尽可能的使用 <span class="built_in">varchar</span> 代替 <span class="built_in">char</span> ，因为首先变长字段存储空间小，可以节省存储空间，</span><br><span class="line">其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。	</span><br><span class="line">	</span><br><span class="line"><span class="number">17.</span>任何地方都不要使用 <span class="keyword">select</span> * <span class="keyword">from</span> t ，用具体的字段列表代替“*”，不要返回用不到的任何字段。	</span><br><span class="line">	</span><br><span class="line"><span class="number">18.</span>避免频繁创建和删除临时表，以减少系统表资源的消耗。</span><br><span class="line"><span class="number">19.</span>临时表并不是不可使用，适当地使用它们可以使某些例程更有效，例如，当需要重复引用大型表或常用表中的某个数据集时。但是，对于一次性事件，最好使用导出表。	</span><br><span class="line">	</span><br><span class="line"><span class="number">20.</span>在新建临时表时，如果一次性插入数据量很大，那么可以使用 <span class="keyword">select</span> <span class="keyword">into</span> 代替 <span class="keyword">create</span> <span class="keyword">table</span>，避免造成大量 <span class="keyword">log</span> ，</span><br><span class="line">以提高速度；如果数据量不大，为了缓和系统表的资源，应先<span class="keyword">create</span> <span class="keyword">table</span>，然后<span class="keyword">insert</span>。</span><br><span class="line"><span class="number">21.</span>如果使用到了临时表，在存储过程的最后务必将所有的临时表显式删除，先 <span class="keyword">truncate</span> <span class="keyword">table</span> ，然后 <span class="keyword">drop</span> <span class="keyword">table</span> ，这样可以避免系统表的较长时间锁定。	</span><br><span class="line">	</span><br><span class="line"><span class="number">22.</span>尽量避免使用游标，因为游标的效率较差，如果游标操作的数据超过<span class="number">1</span>万行，那么就应该考虑改写。</span><br></pre></td></tr></table></figure>

<h2 id="如何用-explain-分析-SQL-执行效率。"><a href="#如何用-explain-分析-SQL-执行效率。" class="headerlink" title="如何用 explain 分析 SQL 执行效率。"></a>如何用 explain 分析 SQL 执行效率。</h2><blockquote>
<p>table ：这一列是查询设计的表。</p>
<p>type ：很重要的一列，显示了查询使用了那种类型，是否使用的索引，能反映出语句的质量。一般这个指标从好到坏依次是：system&gt;const&gt;eq_ref&gt;ref(最好能达到)&gt;fulltext&gt;ref_or_null&gt;index_merge&gt;unique_subquery&gt;index_subquery&gt;range&gt;index&gt;ALL</p>
<p>为了保证查询至少达到range级别。最好达到ref，否则的话，只能说明这条语句性能有待提高。</p>
<p>ref 表示所有具有匹配的索引的行都被用到</p>
<p>range索引范围内查找</p>
<p>index全索引树扫描</p>
<p>all全表扫描</p>
<p>possible_keys：指出mysql在试用了哪个索引在该表中查找行。如果没有使用任何索引，就显示的NULL，可以用于对优化时的索引调整。</p>
<p>key：显示使用的索引，如果没有使用，则显示NULL</p>
<p>key_len：显示的是所使用的索引长度，如果没使用，则是NULL。当然，在使用索引的情况下，索引长度越小。效果越明显。</p>
<p>ref：显示使用那个列或常数雨key一起从表中选择行。</p>
<p>rows：执行查询的行数，如果行数越小，说明查询次数越少，效率越高。</p>
<p>extra：包含查询mysql解决查询的详细信息。</p>
</blockquote>
<p>Explain 用来分析 SELECT 查询语句，开发人员可以通过分析 Explain 结果来优化查询语句。</p>
<p>比较重要的字段有：</p>
<ul>
<li>select_type : 查询类型，有简单查询、联合查询、子查询等</li>
<li>key : 使用的索引</li>
<li>rows : 扫描的行数</li>
</ul>
<hr>
<h2 id="请举出可能形成数据库死锁的原因、如何能避免死锁。"><a href="#请举出可能形成数据库死锁的原因、如何能避免死锁。" class="headerlink" title="请举出可能形成数据库死锁的原因、如何能避免死锁。"></a>请举出可能形成数据库死锁的原因、如何能避免死锁。</h2><p> <strong>死锁产生的四个必要条件</strong><br>•互斥条件：指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放<br>•请求和保持条件：指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放<br>•不剥夺条件：指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放<br>•环路等待条件：指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{P0，P1，P2，···，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源<br>这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。</p>
<blockquote>
<p>数据库和操作系统一样，是一个多用户使用的共享资源。当多个用户并发地存取数据 时，在数据库中就会产生多个事务同时存取同一数据的情况。若对并发操作不加控制就可能会读取和存储不正确的数据，破坏数据库的一致性。加锁是实现数据库并 发控制的一个非常重要的技术。在实际应用中经常会遇到的与锁相关的异常情况，当两个事务需要一组有冲突的锁，而不能将事务继续下去的话，就会出现死锁，严 重影响应用的正常执行。</p>
<p>在数据库中有两种基本的锁类型：排它锁（Exclusive Locks，即X锁）和共享锁（Share Locks，即S锁）。当数据对象被加上排它锁时，其他的事务不能对它读取和修改。加了共享锁的数据对象可以被其他事务读取，但不能修改。数据库利用这两 种基本的锁类型来对数据库的事务进行并发控制。</p>
<p><strong>死锁的第一种情况</strong></p>
<p>一个用户A 访问表A(锁住了表A),然后又访问表B；另一个用户B 访问表B(锁住了表B)，然后企图访问表A；这时用户A由于用户B已经锁住表B，它必须等待用户B释放表B才能继续，同样用户B要等用户A释放表A才能继续，这就死锁就产生了。</p>
<p>解决方法：</p>
<p>这种死锁比较常见，是由于程序的BUG产生的，除了调整的程序的逻辑没有其它的办法。仔细分析程序的逻辑，对于数据库的多表操作时，尽量按照相同的顺序进 行处理，尽量避免同时锁定两个资源，如操作A和B两张表时，总是按先A后B的顺序处理， 必须同时锁定两个资源时，要保证在任何时刻都应该按照相同的顺序来锁定资源。</p>
<p><strong>死锁的第二种情况</strong></p>
<p>用户A查询一条纪录，然后修改该条纪录；这时用户B修改该条纪录，这时用户A的事务里锁的性质由查询的共享锁企图上升到独占锁，而用户B里的独占锁由于A 有共享锁存在所以必须等A释放掉共享锁，而A由于B的独占锁而无法上升的独占锁也就不可能释放共享锁，于是出现了死锁。这种死锁比较隐蔽，但在稍大点的项 目中经常发生。如在某项目中，页面上的按钮点击后，没有使按钮立刻失效，使得用户会多次快速点击同一按钮，这样同一段代码对数据库同一条记录进行多次操 作，很容易就出现这种死锁的情况。</p>
<p>解决方法：</p>
<p>1、对于按钮等控件，点击后使其立刻失效，不让用户重复点击，避免对同时对同一条记录操作。<br>2、使用乐观锁进行控制。乐观锁大多是基于数据版本（Version）记录机制实现。即为数据增加一个版本标识，在基于数据库表的版本解决方案中，一般是 通过为数据库表增加一个“version”字段来实现。读取出数据时，将此版本号一同读出，之后更新时，对此版本号加一。此时，将提交数据的版本数据与数 据库表对应记录的当前版本信息进行比对，如果提交的数据版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据。乐观锁机制避免了长事务中的数据 库加锁开销（用户A和用户B操作过程中，都没有对数据库数据加锁），大大提升了大并发量下的系统整体性能表现。Hibernate 在其数据访问引擎中内置了乐观锁实现。需要注意的是，由于乐观锁机制是在我们的系统中实现，来自外部系统的用户更新操作不受我们系统的控制，因此可能会造 成脏数据被更新到数据库中。<br>3、使用悲观锁进行控制。悲观锁大多数情况下依靠数据库的锁机制实现，如Oracle的Select … for update语句，以保证操作最大程度的独占性。但随之而来的就是数据库性能的大量开销，特别是对长事务而言，这样的开销往往无法承受。如一个金融系统， 当某个操作员读取用户的数据，并在读出的用户数据的基础上进行修改时（如更改用户账户余额），如果采用悲观锁机制，也就意味着整个操作过程中（从操作员读 出数据、开始修改直至提交修改结果的全过程，甚至还包括操作员中途去煮咖啡的时间），数据库记录始终处于加锁状态，可以想见，如果面对成百上千个并发，这 样的情况将导致灾难性的后果。所以，采用悲观锁进行控制时一定要考虑清楚。</p>
<p><strong>死锁的第三种情况</strong></p>
<p>如果在事务中执行了一条不满足条件的update语句，则执行全表扫描，把行级锁上升为表级锁，多个这样的事务执行后，就很容易产生死锁和阻塞。类似的情 况还有当表中的数据量非常庞大而索引建的过少或不合适的时候，使得经常发生全表扫描，最终应用系统会越来越慢，最终发生阻塞或死锁。</p>
<p>解决方法：</p>
<p>SQL语句中不要使用太复杂的关联多表的查询；使用“执行计划”对SQL语句进行分析，对于有全表扫描的SQL语句，建立相应的索引进行优化。<br><strong>5．小结</strong><br>总体上来说，产生内存溢出与锁表都是由于代码写的不好造成的，因此提高代码的质量是最根本的解决办法。有的人认为先把功能实现，有BUG时再在测试阶段进 行修正，这种想法是错误的。正如一件产品的质量是在生产制造的过程中决定的，而不是质量检测时决定的，软件的质量在设计与编码阶段就已经决定了，测试只是 对软件质量的一个验证，因为测试不可能找出软件中所有的BUG。</p>
</blockquote>
<hr>
<h2 id="数据库中的乐观锁和悲观锁有什么区别、各适用于什么场景。"><a href="#数据库中的乐观锁和悲观锁有什么区别、各适用于什么场景。" class="headerlink" title="数据库中的乐观锁和悲观锁有什么区别、各适用于什么场景。"></a>数据库中的乐观锁和悲观锁有什么区别、各适用于什么场景。</h2><ul>
<li>乐观锁：乐观锁的特点先进行业务操作，不到万不得已不去拿锁。即“乐观”的认为拿锁多半是会成功的，因此在进行完业务操作需要实际更新数据的最后一步再去拿一下锁就好。</li>
<li>悲观锁：悲观锁的特点是先获取锁，再进行业务操作，即“悲观”的认为获取锁是非常有可能失败的，因此要先确保获取锁成功再进行业务操作。通常所说的“一锁二查三更新”即指的是使用悲观锁。</li>
</ul>
<p>乐观锁的思路一般是表中增加版本字段，更新时where语句中增加版本的判断，算是一种CAS（Compare And Swep）操作，商品库存场景中number起到了版本控制（相当于version）的作用（ AND number=#{number}）。</p>
<p>悲观锁之所以是悲观，在于他认为本次操作会发生并发冲突，所以一开始就对商品加上锁（SELECT … FOR UPDATE），然后就可以安心的做判断和更新，因为这时候不会有别人更新这条商品库存。</p>
<ul>
<li>乐观锁：比较适合读取操作比较频繁的场景，如果出现大量的写入操作，数据发生冲突的可能性就会增大，为了保证数据的一致性，应用层需要不断的重新获取数据，这样会增加大量的查询操作，降低了系统的吞吐量。</li>
<li>悲观锁：比较适合写入操作比较频繁的场景，如果出现大量的读取操作，每次读取的时候都会进行加锁，这样会增加大量的锁的开销，降低了系统的吞吐量。</li>
</ul>
<hr>
<h2 id="请结合你的开发经历，谈谈数据库中的乐观锁和悲观锁是具体如何被应用的。"><a href="#请结合你的开发经历，谈谈数据库中的乐观锁和悲观锁是具体如何被应用的。" class="headerlink" title="请结合你的开发经历，谈谈数据库中的乐观锁和悲观锁是具体如何被应用的。"></a>请结合你的开发经历，谈谈数据库中的乐观锁和悲观锁是具体如何被应用的。</h2><h2 id="索引的本质。"><a href="#索引的本质。" class="headerlink" title="索引的本质。"></a>索引的本质。</h2><p><strong>以我的理解，索引的本质是基于对象的一个或多个属性按照某种数据结构（树、哈希、有序链表等）进行组织，以加速查找的一种技术。其中有两个关键点，一是基于一个或多个属性，二是数据结构。</strong></p>
<p>首先，每个索引都是基于一个属性的组合来建立的，组合中的属性可以为单个或者多个。建立好对应索引后，这个属性组合就是数据的入口(Entry)。例如，HBase将rowkey作为核心的数据入口，任何不符合rowkey的查找条件都不能直接使用该索引。又例如ElasticSearch等搜索引擎的核心倒排索引，其实是将原本以文档id作为入口的数据，转换为以词为入口，因此全文检索的时候可以直接利用词来快速定位文档。除了这些比较高级的应用，其实我们平时接触的操作系统也有不少索引的应用，最为常见的文件系统就用了基于文件名的B+Tree索引。</p>
<p>由于遍历的时间复杂度是O(n)，那么索引后的查找复杂度必定是小于O(n)才有意义。常用的索引主要有两种：复杂度为O(1)的哈希索引和复杂度为O(log n)的树索引。哈希索引原理是根据属性组合直接通过哈希函数计算出结果数据的地址，一般来说更快（包括建索引的效率和查询效率），具体性能依赖于数据集和哈希函数的匹配程度；树索引原理是基于属性组合建立树再根据二分查找定位数据，虽然建索引和查找速度都慢一些，但优势是可以支持范围查询和front-n属性匹配（前缀匹配）的查询。其中front-n属性的查询意思是，属性组合中的前1到前n个属性组成的子组合的查找。例如属性组合是A-B-C，那么树索引可以支持A、A-B、A-B-C三个属性组合的查找。</p>
<p>这两种索引并不冲突，比如HBase使用的TreeMap（或者说SortedMap）就优雅地结合了两种索引。众所周知HBase是KeyValue型数据库，不知道准确rowkey的时候只能通过scan来查询数据，而这个scan正是利用了树索引的二分查找。<strong>或许没有很多人意识到，经过排序的数据实际上是一棵隐式的树。</strong>这棵树以查询的粒度来确定节点。比如在字符串查找中，查询的粒度是字符，则索引树的每一层代表字符串的一位字符。HBase的rowkey是经过排序的，而且rowkey的组织方式完全由用户决定，接近于字符串查找。所以HBase的数据查询分为两种情况：</p>
<ol>
<li>知道rowkey -&gt; O(1)的哈希查找</li>
<li>不知道rowkey，知道rowkey中前n个字段 -&gt; O(log n)的树查找（确定startkey和endkey） + 局部线性扫描</li>
<li>不知道rowkey，不知道rowkey中前n个字段 -&gt; O(n)的全表线性扫描</li>
</ol>
<p>可以看出，HBase的rowkey组织方式尤为重要，它直接决定了查询用的是什么索引。</p>
<p>以上就是我对索引的理解。</p>
<h2 id="MySQL-存储引擎。"><a href="#MySQL-存储引擎。" class="headerlink" title="MySQL 存储引擎。"></a>MySQL 存储引擎。</h2><p><img src="https://img-blog.csdn.net/20170705172036010?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemdyZ2Zy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p>
<h2 id="MySQL-索引"><a href="#MySQL-索引" class="headerlink" title="MySQL 索引"></a>MySQL 索引</h2><h2 id="数据结构，B-Tree-和-B-Tree。"><a href="#数据结构，B-Tree-和-B-Tree。" class="headerlink" title="数据结构，B-Tree 和 B+Tree。"></a>数据结构，B-Tree 和 B+Tree。</h2><ul>
<li>B树的所有节点既存放 键(key) 也存放 数据(data);而B+树只有叶子节点存放 key 和 data，其他内节点只存放key。</li>
<li>B树的叶子节点都是独立的;B+树的叶子节点有一条引用链指向与它相邻的叶子节点。</li>
<li>B树的检索的过程相当于对范围内的每个节点的关键字做二分查找，可能还没有到达叶子节点，检索就结束了。而B+树的检索效率就很稳定了，任何查找都是从根节点到叶子节点的过程，叶子节点的顺序检索很明显。</li>
</ul>
<h2 id="带有顺序访问指针的-B-Tree"><a href="#带有顺序访问指针的-B-Tree" class="headerlink" title="带有顺序访问指针的 B+Tree"></a>带有顺序访问指针的 B+Tree</h2><h2 id="索引的物理存储。"><a href="#索引的物理存储。" class="headerlink" title="索引的物理存储。"></a>索引的物理存储。</h2><p>当我们创建一个table时， InnoDB会创建三个文件。 一个是表结构定义文件， 另一个为数据实际存储文件， 并且所有的索引也将存放在这个文件中。 最后一个文件保存该table所制定的字符集。</p>
<p><img src="https://smartkeyerror.oss-cn-shenzhen.aliyuncs.com/jojo/system-design/mysql/ibd/innodb-table-structure.png" alt="img"></p>
<h2 id="与-B-Tree-相比，B-Tree-有什么不同。"><a href="#与-B-Tree-相比，B-Tree-有什么不同。" class="headerlink" title="与 B-Tree 相比，B+Tree 有什么不同。"></a>与 B-Tree 相比，B+Tree 有什么不同。</h2><p>B树的所有节点既存放 键(key) 也存放 数据(data);而B+树只有叶子节点存放 key 和 data，其他内节点只存放key。<br>B树的叶子节点都是独立的;B+树的叶子节点有一条引用链指向与它相邻的叶子节点。<br>B树的检索的过程相当于对范围内的每个节点的关键字做二分查找，可能还没有到达叶子节点，检索就结束了。而B+树的检索效率就很稳定了，任何查找都是从根节点到叶子节点的过程，叶子节点的顺序检索很明显。</p>
<h2 id="为什么-B-Tree-更适合做文件索引。"><a href="#为什么-B-Tree-更适合做文件索引。" class="headerlink" title="为什么 B+Tree 更适合做文件索引。"></a>为什么 B+Tree 更适合做文件索引。</h2><p>原因：相对于B树，<br>    （1）B+树空间利用率更高，可减少I/O次数，<br>         一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘I/O消耗。而因为B+树的内部节点只是作为索引使用，而不像B-树那样每个节点都需要存储硬盘指针。<br>         也就是说：B+树中每个非叶节点没有指向某个关键字具体信息的指针，所以每一个节点可以存放更多的关键字数量，即一次性读入内存所需要查找的关键字也就越多，减少了I/O操作。<br>     e.g.假设磁盘中的一个盘块容纳16bytes，而一个关键字2bytes，一个关键字具体信息指针2bytes。一棵9阶B-tree(一个结点最多8个关键字)的内   部结点需要2个盘快。而B+ 树内部结点只需要1个盘快。当需要把内部结点读入内存中的时候，B 树就比B+ 树多一次盘块查找时间(在磁盘中就   是         盘片旋转的时间)。<br>    （2）增删文件（节点）时，效率更高，<br>         因为B+树的叶子节点包含所有关键字，并以有序的链表结构存储，这样可很好提高增删效率。<br>    （3）B+树的查询效率更加稳定，<br>    因为B+树的每次查询过程中，都需要遍历从根节点到叶子节点的某条路径。所有关键字的查询路径长度相同，导致每一次查询的效率相当。</p>
<h2 id="为什么不用-AVL-树或者红黑树做索引。"><a href="#为什么不用-AVL-树或者红黑树做索引。" class="headerlink" title="为什么不用 AVL 树或者红黑树做索引。"></a>为什么不用 AVL 树或者红黑树做索引。</h2><p><strong>一、B+树做索引而不用B-树</strong><br>那么Mysql如何衡量查询效率呢？– 磁盘IO次数。<br>一般来说索引非常大，尤其是关系性数据库这种数据量大的索引能达到亿级别，所以为了减少内存的占用，索引也会被存储在磁盘上。B-树/B+树 的特点就是每层节点数目非常多，层数很少，目的就是为了减少磁盘IO次数，但是B-树的每个节点都有data域（指针），这无疑增大了节点大小，说白了增加了磁盘IO次数（磁盘IO一次读出的数据量大小是固定的，单个数据变大，每次读出的就少，IO次数增多，一次IO多耗时），而B+树除了叶子节点其它节点并不存储数据，节点小，磁盘IO次数就少。</p>
<p>优点一： B+树只有叶节点存放数据，其余节点用来索引，而B-树是每个索引节点都会有Data域。</p>
<p>优点二： B+树所有的Data域在叶子节点，并且所有叶子节点之间都有一个链指针。 这样遍历叶子节点就能获得全部数据，这样就能进行区间访问啦。在数据库中基于范围的查询是非常频繁的，而B树不支持这样的遍历操作。</p>
<p><strong>二、B+树做索引而不用红黑树</strong><br>AVL 树（平衡二叉树）和红黑树（二叉查找树）基本都是存储在内存中才会使用的数据结构。在大规模数据存储的时候，红黑树往往出现由于树的深度过大而造成磁盘IO读写过于频繁，进而导致效率低下的情况。为什么会出现这样的情况，我们知道要获取磁盘上数据，必须先通过磁盘移动臂移动到数据所在的柱面，然后找到指定盘面，接着旋转盘面找到数据所在的磁道，最后对数据进行读写。磁盘IO代价主要花费在查找所需的柱面上，树的深度过大会造成磁盘IO频繁读写。根据磁盘查找存取的次数往往由树的高度所决定，所以，只要我们通过某种较好的树结构减少树的结构尽量减少树的高度，B树可以有多个子女，从几十到上千，可以降低树的高度。</p>
<p>数据库系统的设计者巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入。为了达到这个目的，在实际实现B-Tree还需要使用如下技巧：每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次I/O。</p>
<hr>
<h2 id="两种引擎的索引存储机制。"><a href="#两种引擎的索引存储机制。" class="headerlink" title="两种引擎的索引存储机制。"></a><a href="https://blog.csdn.net/u010922732/article/details/82994253" target="_blank" rel="noopener">两种引擎的索引存储机制。</a></h2><p>分为主键索引和辅助索引来描述。</p>
<p>innodb存储主键索引是叶子节点下跟着一大串除主键外的<strong>行记录</strong>，辅助索引则是一个辅助索引下带着<strong>主键</strong>的值；</p>
<p>myisam主键索引和辅助索引存的都是行记录的<strong>地址</strong>。</p>
<blockquote>
<ol>
<li>role表有三个文件，对应如下：</li>
</ol>
<p>role.frm：表结构文件<br>role.MYD：数据文件（MyISAM Data）<br>role.MYI：索引文件（MyISAM Index）</p>
<ol start="2">
<li>user表有两个文件，对应如下：</li>
</ol>
<p>user.frm：表结构文件<br>user.ibd：索引和数据文件（InnoDB Data）</p>
</blockquote>
<p>MyISAM：每个MyISAM在磁盘上存储成三个文件。第一个文件的名字以表的名字开始，扩展名指出文件类型。.frm文件存储表定义。数据文件的扩展名为.MYD (MYData)。索引文件的扩展名是.MYI (MYIndex)。<br>InnoDB：所有的表都保存在同一个数据文件中（也可能是多个文件，或者是独立的表空间文件），InnoDB表的大小只受限于操作系统文件的大小，一般为2GB。</p>
<hr>
<h2 id="MyISAM-索引实现。"><a href="#MyISAM-索引实现。" class="headerlink" title="MyISAM 索引实现。"></a>MyISAM 索引实现。</h2><h2 id="InnoDB-索引实现。"><a href="#InnoDB-索引实现。" class="headerlink" title="InnoDB 索引实现。"></a>InnoDB 索引实现。</h2><h2 id="索引失效条件。"><a href="#索引失效条件。" class="headerlink" title="索引失效条件。"></a>索引失效条件。</h2><h2 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h2><p>1.普通索引<br>2.唯一索引<br>3.主键索引<br>4.组合索引<br>5.全文索引</p>
<p>从数据结构角度</p>
<p>1、B+树索引(O(log(n)))：关于B+树索引，可以参考 MySQL索引背后的数据结构及算法原理</p>
<p>2、hash索引：<br>a 仅仅能满足”=”,”IN”和”&lt;=&gt;”查询，不能使用范围查询<br>b 其检索效率非常高，索引的检索可以一次定位，不像B-Tree 索引需要从根节点到枝节点，最后才能访问到页节点这样多次的IO访问，所以 Hash 索引的查询效率要远高于 B-Tree 索引<br>c 只有Memory存储引擎显示支持hash索引</p>
<p>3、FULLTEXT索引（现在MyISAM和InnoDB引擎都支持了）</p>
<p>4、R-Tree索引（用于对GIS数据类型创建SPATIAL索引）</p>
<h2 id="哈希索引。"><a href="#哈希索引。" class="headerlink" title="哈希索引。"></a>哈希索引。</h2><p>询速度相对于B-Tree索引是要快，但是也有一些局限：</p>
<p>hash索引中只有hash值和行数的指针，因此无法直接使用索引来避免读取行，但是因为这种索引读取快，性能影响不明显。<br>hash索引不是按照索引值顺序存储，无法使用于排序。<br>不支持部分列匹配查找，这里面是使用索引列的全部内容来计算哈希值，例如(A,B)两列一起建索引，单纯使用A一列，那么就无法使用索引，B-Tree索引的话，因为支持匹配最左前缀，所以这种情况适用性偏好。<br>哈希索引只支持等值查询，包括=、in()、&lt;=&gt;，不支持where age &gt; 10 这种范围查询。<br>哈希冲突很多的话，维护索引操作的代价也很高</p>
<h2 id="有序数组。"><a href="#有序数组。" class="headerlink" title="有序数组。"></a>有序数组。</h2><h2 id="B-树索引（InnoDB）。"><a href="#B-树索引（InnoDB）。" class="headerlink" title="B+ 树索引（InnoDB）。"></a>B+ 树索引（InnoDB）。</h2><h2 id="联合索引。"><a href="#联合索引。" class="headerlink" title="联合索引。"></a>联合索引。</h2><h2 id="索引下推。"><a href="#索引下推。" class="headerlink" title="索引下推。"></a><a href="https://www.shuzhiduo.com/A/kmzLrnQX5G/" target="_blank" rel="noopener">索引下推。</a></h2><blockquote>
<p>索引下推简而言之就是在复合索引由于某些条件(比如 like %aa)失效的情况下，当存在失效的过滤字段在索引覆盖范围内，使用比较的方式在不回表的情况下进一步缩小查询的范围。</p>
<p>其实就是对索引失效的进一步修复，属于最左前缀索引原则的一个意外情况。</p>
<p><strong>索引下推触发的条件</strong></p>
<p>查询条件是符合索引<br>失效条件的字段在索引覆盖的范围内<br>失效条件是可以通过数据进行比较的简单对比<br>以此我们可以推断出索引下推可以使用的场景</p>
<p>like查询<br>函数在左的查询,比如CHAR_LENGTH(colName)=5</p>
</blockquote>
<p>索引条件下推优化（Index Condition Pushdown (ICP) ）是MySQL5.6添加的，用于优化数据查询。 </p>
<p>不使用索引条件下推优化时存储引擎通过索引检索到数据，然后返回给MySQL服务器，服务器然后判断数据是否符合条件。<br>当使用索引条件下推优化时，如果存在某些被索引的列的判断条件时，MySQL服务器将这一部分判断条件传递给存储引擎，然后由存储引擎通过判断索引是否符合MySQL服务器传递的条件，只有当索引符合条件时才会将数据检索出来返回给MySQL服务器。</p>
<p>索引条件下推优化可以减少存储引擎查询基础表的次数，也可以减少MySQL服务器从存储引擎接收数据的次数。 </p>
<blockquote>
<p>对于user_table表，我们现在有（username,age）联合索引<br>如果现在有一个需求，查出名称中以“张”开头且年龄小于等于10的用户信息，语句C如下：”select * from user_table where username like ‘张%’ and age &gt; 10”.<br>语句C有两种执行可能：<br>1、根据（username,age）联合索引查询所有满足名称以“张”开头的索引，然后回表查询出相应的全行数据，然后再筛选出满足年龄小于等于10的用户数据。过程如下图。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5148507-1684dba15ec6fb78.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>2、根据（username,age）联合索引查询所有满足名称以“张”开头的索引，然后直接再筛选出年龄小于等于10的索引，之后再回表查询全行数据。过程如下图。</p>
<p>明显的，第二种方式需要回表查询的全行数据比较少，这就是mysql的索引下推。mysql默认启用索引下推，我们也可以通过修改系统变量optimizer_switch的index_condition_pushdown标志来控制<br><code>SET optimizer_switch = &#39;index_condition_pushdown=off&#39;;</code></p>
</blockquote>
<p>注意点：<br>1、innodb引擎的表，索引下推只能用于二级索引。</p>
<p>就像之前提到的，innodb的主键索引树叶子结点上保存的是全行数据，所以这个时候索引下推并不会起到减少查询全行数据的效果。</p>
<p>2、索引下推一般可用于所求查询字段（select列）不是/不全是联合索引的字段，查询条件为多条件查询且查询条件子句（where/order by）字段全是联合索引。</p>
<p>假设表t有联合索引（a,b）,下面语句可以使用索引下推提高效率<br>select * from t where a &gt; 2 and b &gt; 10;</p>

    </div>

    
    
    

      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/技术/" rel="tag"><i class="fa fa-tag"></i> 技术</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/p/6451.html" rel="prev" title="Arrays.sort比较器对二维数组排序">
      <i class="fa fa-chevron-left"></i> Arrays.sort比较器对二维数组排序
    </a></div>
      <div class="post-nav-item">
    <a href="/p/91c7.html" rel="next" title="jvm">
      jvm <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是数据库事务、数据库事务的四个特性是什么。"><span class="nav-number">1.</span> <span class="nav-text">什么是数据库事务、数据库事务的四个特性是什么。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#请分别举例说明幻读和不可重复读、并描述一下它们之间的区别。"><span class="nav-number">2.</span> <span class="nav-text">请分别举例说明幻读和不可重复读、并描述一下它们之间的区别。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MySQL-的默认隔离级别是什么。"><span class="nav-number">3.</span> <span class="nav-text">MySQL 的默认隔离级别是什么。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#为什么要使用索引。"><span class="nav-number">4.</span> <span class="nav-text">为什么要使用索引。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#索引这么多优点，为什么不对表中每个字段都创建索引呢。"><span class="nav-number">5.</span> <span class="nav-text">索引这么多优点，为什么不对表中每个字段都创建索引呢。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#索引是如何提升查询速度的。"><span class="nav-number">6.</span> <span class="nav-text">索引是如何提升查询速度的。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#请说出你知道的索引失效的几种情况。"><span class="nav-number">7.</span> <span class="nav-text">请说出你知道的索引失效的几种情况。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是聚簇索引与非聚簇索引"><span class="nav-number">8.</span> <span class="nav-text">什么是聚簇索引与非聚簇索引</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MySQL-索引主要使用的数据结构有哪些。"><span class="nav-number">9.</span> <span class="nav-text">MySQL 索引主要使用的数据结构有哪些。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#谈谈-MyISAM-和-InnoDb-实现-BTree-索引方式的区别。"><span class="nav-number">10.</span> <span class="nav-text">谈谈 MyISAM 和 InnoDb 实现 BTree 索引方式的区别。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是覆盖索引、请举例说明。"><span class="nav-number">11.</span> <span class="nav-text">什么是覆盖索引、请举例说明。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#谈谈你对最左前缀原则的理解。"><span class="nav-number">12.</span> <span class="nav-text">谈谈你对最左前缀原则的理解。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MySQL-中-InnoDb-和-MyISAM-有什么区别。"><span class="nav-number">13.</span> <span class="nav-text">MySQL 中 InnoDb 和 MyISAM 有什么区别。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#谈谈如何对SQL进行优化。"><span class="nav-number">14.</span> <span class="nav-text">谈谈如何对SQL进行优化。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如何用-explain-分析-SQL-执行效率。"><span class="nav-number">15.</span> <span class="nav-text">如何用 explain 分析 SQL 执行效率。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#请举出可能形成数据库死锁的原因、如何能避免死锁。"><span class="nav-number">16.</span> <span class="nav-text">请举出可能形成数据库死锁的原因、如何能避免死锁。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据库中的乐观锁和悲观锁有什么区别、各适用于什么场景。"><span class="nav-number">17.</span> <span class="nav-text">数据库中的乐观锁和悲观锁有什么区别、各适用于什么场景。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#请结合你的开发经历，谈谈数据库中的乐观锁和悲观锁是具体如何被应用的。"><span class="nav-number">18.</span> <span class="nav-text">请结合你的开发经历，谈谈数据库中的乐观锁和悲观锁是具体如何被应用的。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#索引的本质。"><span class="nav-number">19.</span> <span class="nav-text">索引的本质。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MySQL-存储引擎。"><span class="nav-number">20.</span> <span class="nav-text">MySQL 存储引擎。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MySQL-索引"><span class="nav-number">21.</span> <span class="nav-text">MySQL 索引</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据结构，B-Tree-和-B-Tree。"><span class="nav-number">22.</span> <span class="nav-text">数据结构，B-Tree 和 B+Tree。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#带有顺序访问指针的-B-Tree"><span class="nav-number">23.</span> <span class="nav-text">带有顺序访问指针的 B+Tree</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#索引的物理存储。"><span class="nav-number">24.</span> <span class="nav-text">索引的物理存储。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#与-B-Tree-相比，B-Tree-有什么不同。"><span class="nav-number">25.</span> <span class="nav-text">与 B-Tree 相比，B+Tree 有什么不同。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#为什么-B-Tree-更适合做文件索引。"><span class="nav-number">26.</span> <span class="nav-text">为什么 B+Tree 更适合做文件索引。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#为什么不用-AVL-树或者红黑树做索引。"><span class="nav-number">27.</span> <span class="nav-text">为什么不用 AVL 树或者红黑树做索引。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#两种引擎的索引存储机制。"><span class="nav-number">28.</span> <span class="nav-text">两种引擎的索引存储机制。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MyISAM-索引实现。"><span class="nav-number">29.</span> <span class="nav-text">MyISAM 索引实现。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#InnoDB-索引实现。"><span class="nav-number">30.</span> <span class="nav-text">InnoDB 索引实现。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#索引失效条件。"><span class="nav-number">31.</span> <span class="nav-text">索引失效条件。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#索引类型"><span class="nav-number">32.</span> <span class="nav-text">索引类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#哈希索引。"><span class="nav-number">33.</span> <span class="nav-text">哈希索引。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#有序数组。"><span class="nav-number">34.</span> <span class="nav-text">有序数组。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#B-树索引（InnoDB）。"><span class="nav-number">35.</span> <span class="nav-text">B+ 树索引（InnoDB）。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#联合索引。"><span class="nav-number">36.</span> <span class="nav-text">联合索引。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#索引下推。"><span class="nav-number">37.</span> <span class="nav-text">索引下推。</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="高等游民"
      src="/images/1.jpeg">
  <p class="site-author-name" itemprop="name">高等游民</p>
  <div class="site-description" itemprop="description">卷发星人/程序猿/指弹菜鸟/社恐肥宅</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">129</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/senup?tab=stars" title="GitHub → https://github.com/senup?tab=stars" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://snailclimb.gitee.io/javaguide/#/" title="Guide → https://snailclimb.gitee.io/javaguide/#/" rel="noopener" target="_blank"><i class="fab fa-google fa-fw"></i>Guide</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.cnblogs.com/senup/" title="cnblog → https://www.cnblogs.com/senup/" rel="noopener" target="_blank"><i class="fab fa-stack-overflow fa-fw"></i>cnblog</a>
      </span>
      <span class="links-of-author-item">
        <a href="/images/wechat_channel.jpg" title="WeChat → /images/wechat_channel.jpg"><i class="fab fa-weixin fa-fw"></i>WeChat</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      DaLao
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://www.justzht.com" title="https://www.justzht.com" rel="noopener" target="_blank">justzht</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://199508.com/" title="https://199508.com/" rel="noopener" target="_blank">大雄</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://blog.fueis.com/" title="https://blog.fueis.com/" rel="noopener" target="_blank">当下</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://blog.qqiyu.cn/" title="https://blog.qqiyu.cn/" rel="noopener" target="_blank">七云</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://noheart.cn/" title="https://noheart.cn/" rel="noopener" target="_blank">今今今生</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.juroku.net/" title="https://www.juroku.net/" rel="noopener" target="_blank">致郁系</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://co5.me/" title="https://co5.me/" rel="noopener" target="_blank">少女癌</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://allenmistake.top/" title="https://allenmistake.top/" rel="noopener" target="_blank">AllenMistake</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://lruihao.cn/" title="https://lruihao.cn/" rel="noopener" target="_blank">李瑞豪</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://leflacon.top/" title="https://leflacon.top/" rel="noopener" target="_blank">LeFlacon</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        
		<div style="display:inline-block;">
		<a href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral" style=""> 
			<img src="/images/yun.png" style="height:30px">
		</a>
		</div>
  <div class="beian"><a href="http://www.beian.miit.gov.cn" rel="noopener" target="_blank">粤ICP备19119668号 </a>
  </div>

<div class="copyright">
  
  &copy; 2017 – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">高等游民</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">309k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">4:41</span>
</div>

        








      </div>
	  

		
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/medium-zoom@1/dist/medium-zoom.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script>



  
  <script>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>




  <script src="/js/local-search.js"></script>








<script>
document.querySelectorAll('.pdfobject-container').forEach(element => {
  let url = element.dataset.target;
  let pdfOpenParams = {
    navpanes : 0,
    toolbar  : 0,
    statusbar: 0,
    pagemode : 'thumbs',
    view     : 'FitH'
  };
  let pdfOpenFragment = '#' + Object.entries(pdfOpenParams).map(([key, value]) => `${key}=${encodeURIComponent(value)}`).join('&');
  let fullURL = `/lib/pdf/web/viewer.html?file=${encodeURIComponent(url)}${pdfOpenFragment}`;

  if (NexT.utils.supportsPDFs()) {
    element.innerHTML = `<embed class="pdfobject" src="${url + pdfOpenFragment}" type="application/pdf" style="height: ${element.dataset.height};">`;
  } else {
    element.innerHTML = `<iframe src="${fullURL}" style="height: ${element.dataset.height};" frameborder="0"></iframe>`;
  }
});
</script>




  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('https://cdn.jsdelivr.net/npm/valine@1.3.9/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'lFV1Gj6XzpRCC1xA9YskKGKv-gzGzoHsz',
      appKey     : 'rCbCQxrpkNpdqAf7NNTJg42D',
      placeholder: "吐槽一波，嗯？",
      avatar     : 'retro',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : true,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

  
  <script type="text/javascript" src="/js/firework.js"></script>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":false,"scale":0.8},"react":{"opacityDefault":0.7,"opacityOnHover":0.8},"log":false});</script></body>
</html>
